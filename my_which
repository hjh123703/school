#!/bin/sh

# INFO: 'which' takes a list of command names and searches the user's PATH 
# to identify the full path of executables matching those commands. 
# If  the '-a' option is provided, all matching paths are displayed, 
# otherwise only the first match is shown

# Flag to track whether '-a' option (list all matches) is enabled
opt_a=0

# Counter to track how many commands were successfully resolved
found=0

# Store arguments passed to the script
args="$@"

# Store number of arguments passed to the script
num_args=$#


# Function: Display usage information and exit
error_usage(){
	#echo "usage: $(basename $0) [-a] name ..." >&2
	echo "usage: which [-a] name ..." >&2
	exit 1
}


# Function: Display 'Command not found' and exit
error_option(){
	echo "which: $arg: Command not found." >&2

}

# Function: Parse and validate command-line arguments 
check_args(){
        # Process options. The ':' before 'a' allows manual handling of unknown flags
	while getopts ":a" options; do
		case "${options}" in
			# if '-a' option is enabled
			a) 
		   	  opt_a=1
		   	  ;;
			# If an unknown option is used, display error message
			?) 
			  echo "which: unknown option -- ${OPTARG}" >&2
			  error_usage 
			  exit 1
		   	  ;;
		esac
	done
       
	# If -a option is enabled, shift to retrieve only file names 
	if [ $opt_a -eq 1 ]; then	
		shift $((OPTIND - 1 ))
		args=$@
		num_args=$num_args-1
	fi

	# If no arguments were entered: ./<program> -a or ./<program> then  display usage error message
	if [ $num_args -eq 0 ]; then
		error_usage
		exit 1
	fi
}


dirs=""

# Path is a colon-separated list of directories in which to find executables. If PATH is not set or is empty, which will use the system's default search path 

# . If PATH is not set or is empty, which will use the system's default search path.
#  _DEF_PATH value was retrieved from official git repo of OPENBSD https://github.com/openbsd/src/blob/master/include/paths.h
IFS=":"

if [ -z "$PATH" ]; then
	path="/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin:/usr/local/bin:/usr/local/sbin"
else
	path="$PATH"
fi

for dir in $path; do
	dirs="$dirs$dir ";
done
unset IFS
	

# Loop over each directory in path and check if corresponding valid file exists
main_function(){
	for arg in $args; do
		is_found=0
		
		case "$arg" in
			# If provided argument is a path to a valid input file
			# Contains '/' --> path
			*/*)
				if [ -f "$arg" ] && [ -x "$arg" ]; then
					echo "$arg"
					found=$found+1
					is_found=1
				fi;;
			*)
				for dir in $dirs; do
					if [ -f "$dir/$arg" ] && [ -x "$dir/$arg" ]; then
						echo "$dir/$arg"
						found=$found+1
						is_found=1
					# If -a option is not used, only display first match
						[ "$opt_a" -eq 0 ] && break
					fi
				done
		esac

		# A diagnostic is given if an executable file with the argument name was not found in the path
		if [ $is_found -eq 0 ]; then
			error_option()
		fi
	done


	# Program exits in the code below

	# Case: All names were successfully resolved
	if [ "$found" -eq "$num_args" ]; then
		exit 0
	fi

	# Case: No names were resolved
	if [ "$found" -eq 0 ]; then
		exit 2
	fi

	# Case: Some names were resolved but not all
	exit 1
}


check_args $@
main_function $@
